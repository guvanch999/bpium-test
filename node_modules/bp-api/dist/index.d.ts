/// <reference types="node" />
/// <reference types="node" />
import { IBpCatalog, IBpLinkedRecord, IBpRecord, IBpRecordExtra, IBpRecordsQuery, IBpRecordsQueryFilter, IBpSection, IBpView, ID, IFileKey, IBpViewAll, IBpHistory, IBpRelation } from './interfaces';
import stream from 'stream';
import { IBpValues } from './values';
interface IOpt {
    /**Имя ресурса API */
    resource: 'record' | 'catalog' | 'section' | 'view' | 'board' | 'histories' | 'relations' | 'file' | 'values' | 'login' | 'availableRecords';
    viewId?: ID;
    boardId?: ID;
    type?: any;
    widgetId?: ID;
    fieldId?: ID;
    sectionId?: ID;
    catalogId?: ID;
    recordId?: ID;
}
/**
 * https://docs.bpium.ru/integrations/api/
 *
 * Класс следит за состоянием  текущей сессии
 * и если нужно пролонгирует её, или получит снова
 *
 * Нужно ОБЯЗАТЕЛЬНО обрабатывать исключения при выполнениях запросов!, иначе возможен выброс до остановки приложения
 * ```
 * //например так
 * try{
 *   await bp.getRecords(...)
 * }catch(e){
 *   notify.error(e.message)
 * }
 * ```
 * Error из axios будет уменьшен для удобного восприятия.
 * Для получения полного Error нужно поставить флаг BP.debug = true
 */
declare class BP {
    readonly domen: string;
    readonly login: string;
    private readonly password;
    readonly protocol: string;
    readonly timeout: number;
    /**Определяет режим вывода ошибок, если true, то ошибки будут выводиться как есть*/
    static debug: boolean;
    readonly baseUrl: string;
    private sidCookie;
    /**
     * Конструктор объекта для последующей работы с api bpium
     * @param domen домен
     * @param login логин
     * @param password пароль
     * @param protocol протокол, по умолчанию https
     * @param timeout по умолчанию 30 секунд
     */
    constructor(domen: string, login: string, password: string, protocol?: string, timeout?: number);
    _getUrl(opt: IOpt): string;
    /**
     * @param {string} url к ресурсу
     * @param {string} method метод обращения к ресурсу
     * @param {Object} data параметры тела запроса
     * @param {Object} params параметры запроса
     * @returns вернет полный ответ из библиотеки axios
     */
    private _requestWithAuthCookie;
    /**
     * @param url к ресурсу
     * @param method метод обращения к ресурсу
     * @param data параметры тела запроса
     * @param params параметры запроса
     * @returns вернет полный ответ из библиотеки axios
     */
    private _requestWithAuthBasic;
    /**
     * https://docs.bpium.ru/integrations/api
     *
     * @param url к ресурсу
     * @param method метод обращения к ресурсу
     * @param data параметры тела запроса
     * @param params параметры запроса
     * @returns вернет полный ответ из библиотеки axios
     */
    private _request;
    /**
     * https://docs.bpium.ru/integrations/api/data/records#poluchit-zapis
     *
     * @param  catalogId id каталога
     * @param  recordId  id записи
     * @param  params  набор возвращаемых полей записей, формат: ["2", "3"]
     * @returns Вернет запись из каталога catalogId и id равный recordId
     */
    getRecordById<ValuesType extends IBpValues>(catalogId: ID, recordId: ID, params?: IBpRecordsQuery): Promise<IBpRecord<ValuesType> & IBpRecordExtra>;
    /**
     * https://docs.bpium.ru/integrations/api/data/records#poluchit-zapisi
     *
     * @param catalogId  id каталога
     * @param params описание параметров в ссылке.
     * Если нужно использовать расширенный фильтр, то его можно подать так:
     * ```
     *  const records = await bp.getRecords(tempCatalogId, {
        filters: JSON.stringify(
          {
            "$and": [
              {2: '1'},
              {4: { "$or": [[1, 2], [2]] }}
            ]
          })
      })
     * ```
     * @returns вернет массив записей
     */
    getRecords<ValuesType extends IBpValues>(catalogId: ID, params?: IBpRecordsQueryFilter): Promise<(IBpRecord<ValuesType>)[]>;
    /**
     * https://docs.bpium.ru/integrations/api/data/catalogs#poluchit-katalog
     *
     * @param catalogId id каталога
     * @returns если catalogId не пусто, то вернет описание полей каталога в виде объекта https://docs.bpium.ru/integrations/api/data/catalogs#poluchit-katalog
     * , если catalogId пустой, то вернет массив описаний всех каталогов
     */
    getCatalog(): Promise<IBpCatalog[]>;
    getCatalog(catalogId: ID): Promise<IBpCatalog>;
    /**
     * https://docs.bpium.ru/integrations/api/data/sections#poluchit-otdely
     *
     * @param sectionId id отдела
     * @returns если sectionId не пусто, вернет объект описания найденного по sectionId отдела,
     *  если sectionId пустой, то  вернет массив всех отделов.
     */
    getSection(): Promise<IBpSection[]>;
    getSection(sectionId: ID): Promise<IBpSection>;
    /**
     * https://docs.bpium.ru/integrations/api/data/views#poluchit-vidy
     *
     * @param catalogId id каталога
     * @param viewId id вида
     * @returns вернет массив видов для каталога если viewId пусто,
     * вернет один вид если viewId не пустой
     */
    getView(catalogId: ID): Promise<IBpViewAll[]>;
    getView(catalogId: ID, viewId: ID): Promise<IBpView>;
    /**
     * https://docs.bpium.ru/manual/reports/widgets
     *
     * @param boardId
     * @param params параметры запроса
     * @param widgetId
     * @param type
     * @returns
     */
    getWidget(boardId: ID, params?: {}, widgetId?: string, type?: string): Promise<any>;
    /**
     * https://docs.bpium.ru/integrations/api/data/istoriya-history#poluchit-istoriyu
     *
     * @param catalogId id каталога
     * @param recordId id записи
     * @param params параметры запроса (см. ссылку)
     * @returns вернет массив записей истории. Если recordId не указан, то вернет историю по всему каталогу
     *
     */
    getHistory(catalogId: ID, recordId?: ID, params?: {
        limit?: number;
        from?: number;
        sortType?: string;
        userId?: ID;
    }): Promise<IBpHistory[]>;
    /**
     * Агрегация. Разложение данных по осям
     * https://docs.bpium.ru/integrations/api/agregate/values
     *
     * @param catalogId  id каталога
     * @param params параметры запроса
     * @returns
     */
    getValues(catalogId: ID, params?: {}): Promise<any>;
    /**
     * Получение связей с записью
     * https://docs.bpium.ru/integrations/api/data/relations-relations
     *
     * @param catalogId id каталога
     * @param recordId  id записи
     * @param params параметры запроса
     * @returns вернет массив связей
     */
    getRelations(catalogId: ID, recordId: ID, params?: Record<string, any>): Promise<IBpRelation[]>;
    /**
     * Получение доступных для связывания записей
     * https://docs.bpium.ru/integrations/api/search/availablerecords
     * @param catalogId id текущего каталога
     * @param fieldId  id поля к котрому происходит подбор записей
     * @param params параметры запроса
     * ```
     * {
     *   title: "абв",//поисковая строка для фильтрации
     *   catalogId: "20"//ограничивает выдачу по определенному каталогу-источнику
     * }
     * ```
     * @return вернет список доступных для связвания записей
     */
    getAvailableRecords(catalogId: ID, fieldId: ID, params?: {
        title?: string;
        catalogId?: ID;
        recordsFilters?: string;
    }): Promise<IBpLinkedRecord[]>;
    /**
     * https://docs.bpium.ru/integrations/api/data/records#sozdat-zapis
     * Добавляет запись в каталог
     *
     * @param catalogId id каталога в который будет добавлена запись
     * @param data Данные для добавления в bpium {"2": "test text", "3": [1,2]}
     * @returns идентификатор созданной записи, пример - {"id": "31015"}
     */
    postRecord(catalogId: ID, data?: IBpValues): Promise<IBpRecord>;
    /**
     * https://docs.bpium.ru/integrations/api/data/catalogs#sozdat-katalog
     * Создать каталог
     *
     * @param data объект описывающий создаваемый каталог с полями:
     * ```
     *name: 'New catalog',
     *icon: 'icon',
     *sectionId: '2',
     *fields: [
     *    {
     *      name: 'Секция',
     *      hint: '',
     *      type: 'group',
     *      config: {},
     *    },
     *    {
     *      name: 'Текст',
     *      hint: 'Подсказка к полю текст',
     *      type: 'text',
     *      config: {
     *        type: 'text',
     *      },
     *    },
     *    ...
     *    ]
     * }
     * ```
     * @returns вернет объект такого вида:
     * ```
     * { id: '119' }
     * ```
     */
    postCatalog(data: Omit<IBpCatalog, 'id'>): Promise<{
        id: string;
    }>;
    /**
     * https://docs.bpium.ru/integrations/api/data/sections#sozdat-otdel
     *
     * Добавление отдела
     * @param data
     * @returns
     */
    postSection(data: Omit<IBpSection, 'id'>): Promise<{
        id: string;
    }>;
    /**
     * https://docs.bpium.ru/integrations/api/data/istoriya-history#napisat-kommentarii
     * @param {int|string} catalogId id каталога
     * @param {int|string} recordId  id записи
     * @param {string} message
     * @returns Объект такого вида
     * ```
     * { id: '1' }
     * ```
     */
    addCommentToHistory(catalogId: ID, recordId: ID, message: string): Promise<{
        id: string;
    }>;
    /**
     * https://docs.bpium.ru/integrations/api/data/records#izmenit-zapis
     *
     * @param catalogId id каталога
     * @param recordId  id записи
     * @param data
     * @returns Объект такого вида
     * ```
     * {
          id: '1',
          catalogId: '114',
          title: 'newText',
          values: { '2': 'newText', '4': [ '3' ] }
        }
     * ```
     */
    patchRecord(catalogId: ID, recordId: ID, data: IBpValues): Promise<IBpRecord & {
        title: string | undefined;
    }>;
    /**
     * https://docs.bpium.ru/integrations/api/data/catalogs#izmenit-katalog
     * @param {int|string} catalogId id каталога
     * @param {Object} data если нет поля data.fields, то поля каталога НЕ будут затронуты патчем,
     * если же есть поле data.fields = [{name:'nameField', type:'text',...}, ...],
     * то все поля будут приведены к новому виду согласно данным в поле data.fields.
     * @returns пусто
     */
    patchCatalog(catalogId: ID, data: Partial<IBpCatalog>): Promise<void>;
    /**
     * Изменить отдел
     * https://docs.bpium.ru/integrations/api/data/sections#izmenit-otdel
     * @param sectionId id отдела
     * @param data Описание отдела
     * @returns пусто
     */
    patchSection(sectionId: ID, data: IBpSection): Promise<void>;
    /**
     * https://docs.bpium.ru/integrations/api/data/views#izmenit-vid
     * Изменить вид
     *
     * @param catalogId id каталога
     * @param viewId
     * @param data
     * @returns
     */
    patchView(catalogId: ID, viewId: ID, data: Partial<IBpView>): Promise<void>;
    /**
     * https://docs.bpium.ru/integrations/api/data/records#udalit-zapis
     * Удалить запись из каталога по id записи
     *
     * @param catalogId id каталога
     * @param recordId  id записи на удаление
     * @returns пусто
     */
    deleteRecord(catalogId: ID, recordId: ID): Promise<void>;
    /**
     * https://docs.bpium.ru/integrations/api/data/catalogs#udalit-katalog
     * Удаляет каталог по его id
     *
     * @param  catalogId id каталог
     * @returns пустой ответ, если удаление успешное
     */
    deleteCatalog(catalogId: ID): Promise<void>;
    /**
     * https://docs.bpium.ru/integrations/api/data/sections#udalit-otdel
     *
     * @param sectionId id удаляемого отдела
     * @returns пустой ответ, если удаление успешное
     */
    deleteSection(sectionId: ID): Promise<void>;
    /**
     * https://docs.bpium.ru/integrations/api/data/records
     * Получение списка записей с возможностью фильтрации, данные собираются несколькими походами
     * по частям. Каждая часть ограничена параметром {limit} (по умолчанию limit = 500)
     *
     * @param {ID} catalogId id каталога
     * @param {Object} params параметры запроса ({limit:10} будет означать что каждый подход запроса
     * данных будет ограничен этим лимитом, но целевое количество будет ограничено 3м аргуменом(maxLimit))
     * @param {int} maxLimit ограничение общего количества записей (по умолчанию = 5000)
     * @returns массив записей из каталога
     */
    getAllRecords<ValuesType extends IBpValues>(catalogId: ID, params?: IBpRecordsQueryFilter, maxLimit?: number): Promise<(IBpRecord<ValuesType>)[]>;
    /**
     * https://docs.bpium.ru/integrations/api/data/files#zagruzka-faila-v-failovoe-khranilishe-bpium
     * @param {string} name
     * @param string} mimeType
     * @param {string} typeStorage
     * @returns вернет объект похожый на этот:
     * ```
     * {
          AWSAccessKeyId: 'nauzhm9iomxwJC0RIGXZ',
          acl: 'private',
          fileId: 31,
          fileKey: '3571/56a17ffa-8582-414b-bfd7-96b29b226859/README FILE.md',
          police: 'eyJleHBpcmF0aW9uIjoiMjAyOS0xMi0wMVQxMjowMDowMC4wMDBaIiwiY29uZGl0aW9ucyI6W3siYnVja2V0IjoiYnBpdW0tdXNlcmRhdGEifSxbInN0YXJ0cy13aXRoIiwiJGtleSIsIjM1NzEvNTZhMTdmZmEtODU4Mi00MTRiLWJmZDctOTZiMjliMjI2ODU5L1JFQURNRSBGSUxFLm1kIl0seyJhY2wiOiJwcml2YXRlIn0sWyJzdGFydHMtd2l0aCIsIiRDb250ZW50LVR5cGUiLCIiXV19',
          redirect: '/api/v1/files/upload?type=s3',
          signature: 'FVKqbkriqg1OFSlfgLeXjM+M2vE=',
          uploadUrl: 'https://storage.yandexcloud.net:443/bpium-userdata',
          name: 'README FILE.md',
          mimeType: 'text/markdown'
        }
     * ```
     */
    getUploadFileKeys(name?: string, mimeType?: string, typeStorage?: string): Promise<IFileKey>;
    /**
     * https://docs.bpium.ru/integrations/api/data/files#zagruzka-faila-v-failovoe-khranilishe-bpium
     * Загрузка файла в bpium по ключу
     *
     * @param {*} fileKeys id ключа который получен в через метод getUploadFileKeys
     * @param {*} streamOrBuffer поток данных для отрпавки на сервер или буфер
     * @returns вернет объект похожый на этот:
     * ```
     * {
          src: 'https://storage.yandexcloud.net:443/bpium-userdata/3571/c994a2d2-7af4-401d-a31b-a175db708bb4/README FILE.md',
          mimeType: 'text/markdown',
          title: 'README FILE.md',
          size: 1902
        }
     * ```
     */
    uploadFile(fileKeys: IFileKey, streamOrBuffer: stream.Readable | Buffer): Promise<{
        src: string;
        mimeType: string;
        title: string;
        size: number;
    }>;
    /**
     * Удобный таймер сделан для получения паузы в асинхронных функциях
     * Использовать можно так:
     * ```
     *   await bp.pause(30000) //pause 30sec
     * ```
     * @param {} timer 500 по умолчанию
     * @returns вернет Promise который будет обрабатываться ровно timer милисекунд
     */
    pause(timer?: number): Promise<boolean>;
}
export default BP;
export * from './interfaces';
export * from './values';
//# sourceMappingURL=index.d.ts.map